#!/usr/bin/env python3

# zxngdefmt



__version__ = "0.1"



import re
import sys



# --- constants ---



# <?>_RE = string
#
# Regular expressions to match various bits of NextGuide markup.


# link to another node
LINK_RE = r'@{ *"(?P<text>[^"]+)" LINK [^ }]+ *}'

# formatting attribute
ATTR_RE = r"@{\w+}"

# literal characters
LITERALTOKEN_RE = "@(?P<char>[^{])"

# plain (unformatted) word (as opposed to markup)
WORD_RE = "[^@ ]+"

# one or more spaces
SPACE_RE = " +"

# match any type of markup token or word or block of spaces
TOKEN_RE = (r"(?P<token>"
            + LINK_RE
            + r'|' + ATTR_RE
            + r'|' + LITERALTOKEN_RE
            + r'|' + WORD_RE
            + r'|' + SPACE_RE
            + r')'
            + r"(?P<remainder>.*)")


# LITERALLINE_RE = string
#
# Regular expression to match lines which must be included in the output
# guide literally (i.e. without reformatting).  Includes:

LITERALLINE_RE = (r'('

                  # lines with leading spaces
                  + r"\s+"

                  # lines with 3 or more consecutive spaces
                  + r"|.+\s{3,}"

                  # lines beginning with '@' but not '@@' or '@{' -
                  # these indicate node names, lines to adjacent pages
                  # or TOC/index pages
                  + r"|@[^{@]"

                  # lines with centred or right-justified text
                  + r"|@{[cr]}"

                  # lines with headers
                  + r"|.*@{h\d}"

                  # lines consisting solely of a single link
                  + r'|' + LINK_RE + r'$'

                  + r')')



# maximum length for a single line in the output guide

LINE_MAXLEN = 80



# --- functions ---



def render_token(t):
    """Render a NextGuide token (which could be markup, or a literal
    word, or block of spaces) into the text that would be displayed on
    screen (ignoring formatting).  This is used to work out the length
    of rendered markup and calculate displayed line lengths; it is not
    used to generate output.
    """

    # if the token is a link, use the displayed text field
    m = re.match(LINK_RE, t)
    if m:
        return m["text"]

    # if the token is a literal character, convert that to the displayed
    # character
    m = re.match(LITERALTOKEN_RE, t)
    if m:
        c = m["char"]

        # '@(' is the copyright sign
        if c == "(":
            return "\N{COPYRIGHT SIGN}"

        else:
            return c

    # attribute formatting codes don't render to anything displayed
    m = re.match(ATTR_RE, t)
    if m:
        return ""

    # we have a literal word or block of spaces - just use that directly
    return t



line_markup = ""
line_render = ""

word_markup = ""
word_render = ""

space = ""


def writeline():
    """If there is anything in it, write the current line buffer out and
    clear it, ready for the next line.
    """
    global line_markup, line_render
    if line_markup:
        print(line_markup)
        line_markup = ""
        line_render = ""


def writeliteral(l=""):
    """Write a literal line.
    """
    global line_markup, word_markup, space
    if line_markup or word_markup:
        raise AssertionError("line or word buffers not empty when"
                             " writing literal line")
    print(l)
    # if we had a space from the previous line, scrap that
    space = ""


def completeword():
    """Complete the current word.  If the rendered word would fit on the
    current line, it is just appended.  If, however, it would flow out
    of the right margin, the current line will be completed and a new
    line begun with the current word.

    Returns True if a word was completed.
    """
    global line_markup, line_render, word_markup, word_render, space

    # if no word or line, return False as we didn't actually complete a word
    if (not line_render) and (not word_render):
        return False

    if len(line_render + space + word_render) > LINE_MAXLEN:
        writeline()
        # don't add the space, as we're beginning a new line
    else:
        # add the space, as we're continuing the line
        line_markup += space
        line_render += space

    line_markup += word_markup
    line_render += word_render

    # start a new word with no space
    word_markup = ""
    word_render = ""
    space = ""

    # we completed a word so return True
    return True


def appendtoken(t):
    """Append the supplied token to the current word.
    """
    global word_markup, word_render
    word_markup += t
    word_render += render_token(t)


with sys.stdin as f:
    for l in f:
        # remove any trailing whitespace
        l = l.rstrip()

        if re.match(LITERALLINE_RE, l):
            writeline()
            writeliteral(l)
            continue

        # if the line is blank, we complete any line we're building up
        # and write a blank line
        if not l:
            writeline()
            writeliteral()
            space = ""
            continue

        # go through bits of line
        while l:
            m = re.match(TOKEN_RE, l)
            if not m:
                print(f"Something has gone wrong matching <{l}>!")
                exit(1)
            g = m.groupdict()
            token = g["token"]
            #print(f"TOKEN >>> <{token}>")
            l = g["remainder"]
            #print(f"REMAINDER >>> <{l}>")

            if re.match(SPACE_RE, token):
                completeword()
                space = token
                continue

            appendtoken(token)

        # end of line completes a word and adds a space
        if completeword():
            space = " "

# if there is something in the buffer
writeline()
